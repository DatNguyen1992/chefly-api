{"version":3,"file":"auth.service.js","sourceRoot":"","sources":["../../src/auth/auth.service.ts"],"names":[],"mappings":"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","sourcesContent":["import { Injectable, UnauthorizedException } from '@nestjs/common';\nimport { JwtService } from '@nestjs/jwt';\nimport { ConfigService } from '@nestjs/config';\nimport * as bcrypt from 'bcrypt';\nimport { LoginDto, TokensDto } from './dto/auth.dto';\nimport { UsersService } from '@users/users.service';\nimport { RedisService } from 'src/redis/redis.service';\nimport { User } from '@users/schemas/user.schema';\n\n@Injectable()\nexport class AuthService {\n  constructor(\n    private jwtService: JwtService,\n    private configService: ConfigService,\n    private userService: UsersService,\n    private redisService: RedisService,\n  ) {}\n\n  async validateUser(email: string, password: string): Promise<any> {\n    const user = await this.userService.findOne({ email });\n    if (user && (await bcrypt.compare(password, user.password))) {\n      //eslint-disable-next-line @typescript-eslint/no-unused-vars\n      const { password, ...result } = user.toObject();\n      return result;\n    }\n    return null;\n  }\n\n  async login(loginDto: LoginDto): Promise<TokensDto> {\n    const user = await this.validateUser(loginDto.email, loginDto.password);\n    if (!user) {\n      throw new UnauthorizedException('Invalid credentials');\n    }\n    return this.generateTokens(user);\n  }\n\n  async handleOAuthLogin(profile: any): Promise<TokensDto> {\n    let user = await this.userService.findOne({\n      email: profile.email,\n      provider: profile.provider,\n    });\n\n    if (!user) {\n      user = await this.userService.create({\n        email: profile.email,\n        name: profile.name,\n        provider: profile.provider,\n        providerId: profile.providerId,\n      });\n      //TODO: create default folder\n    }\n    return this.generateTokens(user);\n  }\n\n  async refreshTokens(user: User): Promise<TokensDto> {\n    const provider = user.provider || 'local';\n    const tokenKeyPrefix = `${provider}_user`;\n\n    await Promise.all([\n      this.redisService.del(`${tokenKeyPrefix}:${user._id}:refresh_token`),\n      this.redisService.del(`${tokenKeyPrefix}:${user._id}:access_token`),\n    ]);\n\n    return this.generateTokens(user);\n  }\n\n  async logout(userId: string, provider: string = 'local'): Promise<void> {\n    const tokenKeyPrefix = `${provider}_user`;\n\n    await Promise.all([\n      this.redisService.del(`${tokenKeyPrefix}:${userId}:refresh_token`),\n      this.redisService.del(`${tokenKeyPrefix}:${userId}:access_token`),\n    ]);\n  }\n\n  async generateTokens(user: any): Promise<TokensDto> {\n    const payload = {\n      email: user.email,\n      sub: user._id,\n      provider: user.provider || 'local',\n    };\n\n    const [accessToken, refreshToken] = await Promise.all([\n      this.jwtService.signAsync(payload, {\n        secret: this.configService.get('jwt.accessToken.secret'),\n        expiresIn: this.configService.get('jwt.accessToken.expiresIn'),\n      }),\n      this.jwtService.signAsync(payload, {\n        secret: this.configService.get('jwt.refreshToken.secret'),\n        expiresIn: this.configService.get('jwt.refreshToken.expiresIn'),\n      }),\n    ]);\n\n    // Store tokens in Redis with expiration\n    const refreshTokenExpiry = this.configService.get(\n      'jwt.refreshToken.expiresInSeconds',\n    );\n    const accessTokenExpiry = this.configService.get(\n      'jwt.accessToken.expiresInSeconds',\n    );\n\n    // Use a consistent key format for all providers\n    const tokenKeyPrefix = `${user.provider || 'local'}_user`;\n    await Promise.all([\n      this.redisService.set(\n        `${tokenKeyPrefix}:${user._id}:refresh_token`,\n        refreshToken,\n        refreshTokenExpiry,\n      ),\n      this.redisService.set(\n        `${tokenKeyPrefix}:${user._id}:access_token`,\n        accessToken,\n        accessTokenExpiry,\n      ),\n    ]);\n\n    return { accessToken, refreshToken };\n  }\n}\n"]}